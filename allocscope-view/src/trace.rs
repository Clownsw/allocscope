/*
    allocscope  -  a memory tracking tool
    Copyright (C) 2023  Matt Kimball

    This program is free software: you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by the
    Free Software Foundation, either version 3 of the License, or (at your
    option) any later version.

    This program is distributed in the hope that it will be useful, but
    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
    or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
    for more details.

    You should have received a copy of the GNU General Public License along
    with this program. If not, see <https://www.gnu.org/licenses/>.
*/

use rusqlite;
use std::error::Error;

// Primary key identifiers for tables in the trace.
pub type EventId = u64;
pub type StackEntryId = u64;
pub type LocationId = u64;

// A row from the event table.
#[derive(Clone, Debug)]
pub struct Event {
    // The primary key id.
    pub id: EventId,

    // If true an allocation, if false a free.
    pub allocation: bool,

    // The address of the memory.
    pub address: u64,

    // The size of the block.  Not present for frees.
    pub size: Option<u64>,

    // The leaf stack entry of the callstack when the event was generated.
    pub callstack: Option<StackEntryId>,
}

// A row from the stack entry table.  A callstack consists of multiple chained
// stack entries.
#[derive(Clone, Debug)]
pub struct StackEntry {
    // The primary key id.
    pub id: StackEntryId,

    // The id of the row in the location table corresponding to the source
    // location.
    pub location: LocationId,

    // The parent stack entry of this stack entry.
    pub next: Option<StackEntryId>,
}

// A row from the location table describing the source code location.
#[derive(Clone, Debug)]
pub struct Location {
    // The primary key id.
    pub id: LocationId,

    // The address in the memory space of the traced process.
    pub address: u64,

    // The name of the function.
    pub function: Option<String>,

    // The byte offset in the code from the start of the function.
    pub offset: Option<u64>,
}

// A row from the stack entry summary table.
#[derive(Clone, Debug)]
pub struct StackEntrySummary {
    // The id of the stack entry being summarized.
    pub stackentry: StackEntryId,

    // The total number of bytes still allocated as far as the event stream
    // has been processed so far.  This value is increased for allocations and
    // decreased for frees.
    pub current_total: u64,

    // The largest historical value of 'current_total'.
    pub maximum_total: u64,

    // The number of allocations made so far.
    pub alloc_count: u64,

    // The number of allocations freed so far.
    pub free_count: u64,
}

// SQLite database connections for a trace.
pub struct Trace {
    // The trace file originally generated by allocscope-trace.
    atrace_connection: rusqlite::Connection,

    // The scratch database ued by allocscope-view for summaries.
    scratch_connection: rusqlite::Connection,
}

// A SQLite transaction used to retrieve data from the trace and summarize.
pub struct Transaction<'trace_lifetime> {
    // The SQLite connections.
    pub trace: &'trace_lifetime Trace,

    // If true, the transaction has been committed.
    complete: bool,

    // Prepared SQL for retrieving an event by id.
    event_statement: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for retrieving a stack entry by id.
    stackentry_statement: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for retrieving a location by id.
    location_statement: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for retrieving all root stack entries.  (That is to say,
    // stack entries which have no parent.)
    root_stackentries_statement: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for retrieving all children of a stack entry.
    get_stackentry_children_statement: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for retrieving the originating event by allocation
    // address.
    allocation_origin_statement: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for inserting the originating event by allocation address.
    insert_allocation_origin_statement: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for removing assocation between event and allocation
    // address.
    remove_allocation_origin_statement: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for retriving an allocation summary given a stackentry id.
    summary_statement: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for replacing the summary values for a stackentry id.
    add_to_summary_statement: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for retrieving the descendent count for a stackentry.
    descendent_count: rusqlite::Statement<'trace_lifetime>,

    // Prepared SQL for replacing the descendent count for a stackentry.
    add_to_descendent_count: rusqlite::Statement<'trace_lifetime>,
}

impl<'trace_lifetime> Transaction<'trace_lifetime> {
    // Start a new transaction, preparing SQL statements which we may use.
    pub fn new(
        trace: &'trace_lifetime Trace,
    ) -> Result<Transaction<'trace_lifetime>, Box<dyn Error>> {
        trace.scratch_connection.execute("BEGIN TRANSACTION", [])?;

        Ok(Transaction {
            trace: trace,
            complete: false,

            event_statement: trace
                .atrace_connection
                .prepare("SELECT allocation, address, size, callstack FROM event WHERE id = ?")?,
            stackentry_statement: trace
                .atrace_connection
                .prepare("SELECT location, next FROM stackentry WHERE id = ?")?,
            location_statement: trace
                .atrace_connection
                .prepare("SELECT address, function, offset FROM location WHERE id = ?")?,
            root_stackentries_statement: trace
                .atrace_connection
                .prepare("SELECT id, location FROM stackentry WHERE next IS NULL")?,
            get_stackentry_children_statement: trace
                .atrace_connection
                .prepare("SELECT id, location FROM stackentry WHERE next = ?")?,

            allocation_origin_statement: trace
                .scratch_connection
                .prepare("SELECT event FROM allocation_origin WHERE address = ?")?,
            insert_allocation_origin_statement: trace.scratch_connection.prepare(
                "INSERT INTO allocation_origin (address, event)
                    VALUES (?, ?)",
            )?,
            remove_allocation_origin_statement: trace
                .scratch_connection
                .prepare("DELETE FROM allocation_origin WHERE address = ?")?,
            summary_statement: trace.scratch_connection.prepare(
                "SELECT current_total, maximum_total, alloc_count, free_count
                    FROM stackentry_summary WHERE stackentry = ?",
            )?,
            add_to_summary_statement: trace.scratch_connection.prepare(
                "INSERT OR REPLACE INTO stackentry_summary
                    (stackentry, current_total, maximum_total, alloc_count, free_count)
                    VALUES (?, ?, ?, ?, ?)",
            )?,
            descendent_count: trace.scratch_connection.prepare(
                "SELECT descendent_count FROM stackentry_descendents WHERE stackentry = ?",
            )?,
            add_to_descendent_count: trace.scratch_connection.prepare(
                "INSERT OR REPLACE INTO stackentry_descendents
                    (stackentry, descendent_count) VALUES (?, ?)",
            )?,
        })
    }

    // Commit the summary changes the database.
    pub fn commit(&mut self) -> Result<(), Box<dyn Error>> {
        if self.complete {
            return Err("transaction already complete".into());
        }

        self.trace.scratch_connection.execute("COMMIT", []).unwrap();
        self.complete = true;

        Ok(())
    }

    // Retrieve an event by id.
    pub fn event(&mut self, id: EventId) -> Option<Event> {
        let mut rows = self.event_statement.query(rusqlite::params![id]).ok()?;
        let row = rows.next().ok()??;

        Some(Event {
            id,
            allocation: row.get(0).ok()?,
            address: row.get(1).ok()?,
            size: row.get(2).ok(),
            callstack: row.get(3).ok(),
        })
    }

    // Retrieve a stack entry by id.
    pub fn stackentry(&mut self, id: StackEntryId) -> Option<StackEntry> {
        let mut rows = self
            .stackentry_statement
            .query(rusqlite::params![id])
            .ok()?;
        let row = rows.next().ok()??;

        Some(StackEntry {
            id,
            location: row.get(0).ok()?,
            next: row.get(1).ok(),
        })
    }

    // Retrieve a location by id.
    pub fn location(&mut self, id: LocationId) -> Option<Location> {
        let mut rows = self.location_statement.query(rusqlite::params![id]).ok()?;
        let row = rows.next().ok()??;

        Some(Location {
            id,
            address: row.get(0).ok()?,
            function: row.get(1).ok(),
            offset: row.get(2).ok(),
        })
    }

    // Get all stack entries which have no children.
    pub fn root_stackentries(&mut self) -> Result<Vec<StackEntry>, Box<dyn Error>> {
        let mut entries = Vec::new();
        let mut rows = self
            .root_stackentries_statement
            .query(rusqlite::params![])?;
        while let Some(row) = rows.next()? {
            entries.push(StackEntry {
                id: row.get(0)?,
                location: row.get(1)?,
                next: None,
            });
        }

        Ok(entries)
    }

    // Get all the children of a stack entry.
    pub fn get_stackentry_children(
        &mut self,
        id: StackEntryId,
    ) -> Result<Vec<StackEntry>, Box<dyn Error>> {
        let mut entries = Vec::new();
        let mut rows = self
            .get_stackentry_children_statement
            .query(rusqlite::params![id])?;

        while let Some(row) = rows.next()? {
            entries.push(StackEntry {
                id: row.get(0)?,
                location: row.get(1)?,
                next: Some(id),
            });
        }

        Ok(entries)
    }

    // Retrieve the originating event for an allocation given its address.
    pub fn allocation_origin(&mut self, address: u64) -> Option<EventId> {
        let mut rows = self
            .allocation_origin_statement
            .query(rusqlite::params![address])
            .ok()?;
        let row = rows.next().ok()??;

        row.get(0).ok()
    }

    // Assocate an event as originating an allocation for an address.
    pub fn insert_allocation_origin(
        &mut self,
        address: u64,
        event: EventId,
    ) -> Result<(), Box<dyn Error>> {
        self.insert_allocation_origin_statement
            .execute(rusqlite::params![address, event])?;

        Ok(())
    }

    // Remove the association between address and originating event.
    pub fn remove_allocation_origin(&mut self, address: u64) -> Result<(), Box<dyn Error>> {
        self.remove_allocation_origin_statement
            .execute(rusqlite::params![address])?;

        Ok(())
    }

    // Retrieve the allocation summary for a stack entry.
    pub fn summary(&mut self, stackentry: StackEntryId) -> Option<StackEntrySummary> {
        let mut rows = self
            .summary_statement
            .query(rusqlite::params![stackentry])
            .ok()?;
        let row = rows.next().ok()??;

        Some(StackEntrySummary {
            stackentry: stackentry,
            current_total: row.get(0).ok()?,
            maximum_total: row.get(1).ok()?,
            alloc_count: row.get(2).ok()?,
            free_count: row.get(3).ok()?,
        })
    }

    // Add a new allocation or free event to the summary for a stackentry.
    pub fn add_to_summary(
        &mut self,
        stackentry: StackEntryId,
        allocation: bool,
        size: i64,
    ) -> Result<(), Box<dyn Error>> {
        let previous = match self.summary(stackentry) {
            Some(summary) => summary,
            None => StackEntrySummary {
                stackentry,
                current_total: 0,
                maximum_total: 0,
                alloc_count: 0,
                free_count: 0,
            },
        };

        let new_total = previous.current_total as i64 + size;
        let new_max = std::cmp::max(new_total, previous.maximum_total as i64);
        let new_alloc_count = previous.alloc_count + if allocation { 1 } else { 0 };
        let new_free_count = previous.free_count + if allocation { 0 } else { 1 };
        self.add_to_summary_statement.execute(rusqlite::params![
            stackentry,
            new_total,
            new_max,
            new_alloc_count,
            new_free_count
        ])?;
        Ok(())
    }

    // Retrieve the descendent count for a stack entry.
    pub fn descendent_count(&mut self, stackentry: StackEntryId) -> Result<u64, Box<dyn Error>> {
        let mut rows = self.descendent_count.query(rusqlite::params![stackentry])?;

        if let Ok(Some(row)) = rows.next() {
            Ok(row.get(0)?)
        } else {
            Ok(0)
        }
    }

    // Increase the descendent count for a stack entry by one.
    pub fn increment_descendents(
        &mut self,
        stackentry: StackEntryId,
    ) -> Result<(), Box<dyn Error>> {
        let count = self.descendent_count(stackentry)?;

        self.add_to_descendent_count
            .execute(rusqlite::params![stackentry, count + 1,])?;

        Ok(())
    }
}

impl<'trace_lifetime> Drop for Transaction<'trace_lifetime> {
    // If the transaction hasn't been committed when we are dropped, roll it
    // back.
    fn drop(&mut self) {
        if !self.complete {
            self.trace
                .scratch_connection
                .execute("ROLLBACK", [])
                .unwrap();
            self.complete = true;
        }
    }
}

#[allow(dead_code)]
impl Trace {
    // Open a trace file and create a corresponding scratch database for
    // summaries.
    pub fn new(atrace_filename: &str, scratch_filename: &str) -> Result<Trace, Box<dyn Error>> {
        let atrace_connection = rusqlite::Connection::open_with_flags(
            atrace_filename,
            rusqlite::OpenFlags::SQLITE_OPEN_READ_ONLY
                | rusqlite::OpenFlags::SQLITE_OPEN_URI
                | rusqlite::OpenFlags::SQLITE_OPEN_NO_MUTEX,
        )?;

        let scratch_connection = rusqlite::Connection::open(scratch_filename)?;

        // These pragmas improve write performance a bit.
        scratch_connection.execute_batch(
            "PRAGMA journal_mode = OFF;
            PRAGMA synchronous = 0;
            PRAGMA locking_mode = EXCLUSIVE;
            PRAGMA temp_store = MEMORY;",
        )?;

        scratch_connection.execute(
            "CREATE TABLE IF NOT EXISTS allocation_origin (
                address INTEGER PRIMARY KEY,
                event INTEGER NOT NULL
            )",
            [],
        )?;

        scratch_connection.execute(
            "CREATE TABLE IF NOT EXISTS stackentry_summary (
                stackentry INTEGER PRIMARY KEY,
                current_total INTEGER NOT NULL,
                maximum_total INTEGER NOT NULL,
                alloc_count INTEGER NOT NULL,
                free_count INTEGER NOT NULL
            )",
            [],
        )?;

        scratch_connection.execute(
            "CREATE TABLE IF NOT EXISTS stackentry_descendents (
                stackentry INTEGER PRIMARY KEY,
                descendent_count INTEGER NOT NULL
            )",
            [],
        )?;

        Ok(Trace {
            atrace_connection,
            scratch_connection,
        })
    }

    // Return the largest id from the event table.
    pub fn max_event_id(&self) -> Result<EventId, Box<dyn Error>> {
        self.atrace_connection
            .query_row("SELECT MAX(id) FROM event", [], |row| row.get(0))
            .ok()
            .ok_or("failure selecting max event id".into())
    }

    // Return the lagest id from the stack entry table.
    pub fn max_stackentry_id(&self) -> Result<StackEntryId, Box<dyn Error>> {
        self.atrace_connection
            .query_row("SELECT MAX(id) FROM stackentry", [], |row| row.get(0))
            .ok()
            .ok_or("failure selecting stack entry id".into())
    }
}
